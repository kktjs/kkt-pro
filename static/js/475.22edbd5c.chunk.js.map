{"version":3,"file":"static/js/475.22edbd5c.chunk.js","mappings":"8GACA,WACIA,WAAY,CAAG,EACfC,KAAM,CAAC,EACPC,OAAQ,qn7C","sources":["../../packages/query/README.md"],"sourcesContent":["\nexport default {\n    components: {  },\n    data: {},\n    source: \"API 请求\\n===\\n\\n`kktprc` 配置 `queryClient`开启。 `@kkt/request` 内置了 `react-query`（和 [`@tanstack/react-query`](https://npmjs.com/@tanstack/react-query)<!--rehype:target=__blank--> 是同一个）请求方案。更多 API 方法请查看 [react-query 官方文档](https://tanstack.com/query/latest)。\\n\\n## `kktp`配置文件\\n\\n```ts\\n// .kktprc.ts\\nexport default {\\n  queryClient: true\\n}\\n```\\n\\n\\n```js\\nimport { useReactQuery, useReactMutation, queryClient, fetchFn } from '@kkt/request';\\n// OR\\nimport { useReactQuery, useReactMutation, queryClient, fetchFn } from '@kkt/pro';\\n```\\n\\n## API 比较说明\\n\\n &nbsp; | `useReactQuery` | ~~`useQuery`~~ |  `useReactMutation` | ~~`useMutation`~~\\n:--- | :--- | :--- | :--- | :---\\n说明 | 基于 `useQuery` 封装 | 官方 API | 基于 `useMutation` 封装 | 官方 API\\n拼接前缀 | ✅ | 🛑 | ✅ | 🛑\\n集成 fetch 函数 | ✅ | 🛑 | ✅ | 🛑\\n添加头信息 | ✅ | 🛑 | ✅ | 🛑\\nmethod | ✅ 默认(GET) | 🛑 | ✅ 默认(POST) | 🛑\\n请求自动带 token | ✅ | 🛑 | ✅ | 🛑\\n自动更新 token | ✅ | 🛑 | ✅ | 🛑\\nBody 自动转换 | ✅ | 🛑 | ✅ | 🛑\\n\\n推荐使用我们二次封包的 API，否则您需要集成上述功能\\n\\n- [ ] 请求自动带 token\\n- [ ] 自动更新 token\\n\\n## API 请求 hooks\\n\\n下面是 API 请求示例，如 GET/POST 请求示例\\n\\n### useReactQuery\\n\\n主要用于**默认**触发请求数据，默认 `GET` 请求，变更使用 `method=\\\"POST\\\"` 参数配置\\n\\n```jsx\\nuseReactQuery({ \\n  queryKey: ['user', userId], \\n  url: `/api/user/list?id=${userId}`\\n});\\n```\\n<!--rehype:style=background:#00de2247;border: 0;-->\\n\\n👆👆👆👆 上面是**推荐**使用 👆👆👆👆👆\\n\\n```jsx\\nimport { fetchFn, useReactQuery } from '@kkt/request';\\n\\nuseReactQuery({ queryKey: ['user'], url: '/api/user/list' });\\nuseReactQuery({ queryKey: ['user'], url: '/api/user/list', method: 'POST' });\\nuseReactQuery({ queryKey: ['user', userId], queryFn: () => fetchFn(`/api/user/list?id=${userId}`) });\\nuseReactQuery({\\n  queryKey: ['user', userId],\\n  queryFn: async () => {\\n    return fetchFn(`/api/user/list?id=${userId}`);\\n  },\\n});\\nuseReactQuery({\\n  queryKey: ['user', userId],\\n  queryFn: ({ queryKey }) => fetchFn(`/api/user/list?id=${queryKey[1]}`);,\\n});\\nuseReactQuery({\\n  queryKey: ['user'],\\n  url: '/api/user/list',\\n  initialData: [....],\\n});\\n\\nconst { isInitialLoading, isError, data, error, refetch, isFetching } = useQuery(...)\\n```\\n\\n示例\\n\\n```javascript\\nimport { useReactQuery } from '@kkt/request';\\n\\nexport default function HomePage() {\\n  const { isLoading, isError, data } = useReactQuery({\\n    url: `/api/user/list`,\\n    queryKey: ['user-list'],\\n  });\\n\\n  return (\\n    <div>\\n      <p className=\\\"title\\\">ANEM x react-query</p>\\n      {isError && <p>请求 API 错误 ...</p>}\\n      {isLoading && <p>Loading ...</p>}\\n      {data && <p>ANEM 现在有 {data.stargazers_count} 颗星！</p>}\\n    </div>\\n  );\\n}\\n```\\n\\n#### Query 选项\\n\\n可选选项，请求的数据进行处理等其它常用[选项](https://tanstack.com/query/v4/docs/react/reference/useQuery)，可以用于默认全局配置 `QueryClientConfig` 的设置。\\n\\n> 注意：`.anerc.js` 默认已经在 `QueryClientConfig` 中默认全局配置，可以进行增加配置，配置 `react-query=false` 取消注销全局 `QueryClient`，可以自己注册 `QueryClient`\\n\\n```js\\nconst { data } = useReactQuery({\\n  /** 设置 Content-Type，默认值 `json`，'Content-Type' = 'application/json' */\\n  contentType: \\\"json\\\" | 'form';\\n  // 请求 API\\n  url: '/api/user/list'\\n  // 用于此查询的查询键。查询键将被 hash 成一个稳定的 hash 。当此键更改时，查询将自动更新（只要 enabled 未设置为 false）\\n  queryKey: ['user-list', userId],\\n  // 只要查询成功获取新数据，此函数就会触发。\\n  onSuccess: (data: TData) => void\\n  // 如果查询遇到错误并将传递错误，则此函数将触发。\\n  onError: (error: TError) => void\\n  // 每当成功获取查询或出错并传递数据或错误时，此函数都会触发。\\n  onSettled: (data?: TData, error?: TError) => void\\n  // 此选项可用于转换或选择查询函数返回的部分数据。 它会影响返回的数据值，但不会影响存储在查询缓存中的内容。\\n  select: (data: TData) => unknown\\n  select: (dt) => {\\n    // 改变请求到的 data 数据，返回部分 data 数据\\n    return dt\\n  },\\n  // 将此设置为 true 以启用暂停模式。\\n  // 当 true 时，useQuery 将在 status === 'loading' 时暂停\\n  // 当 true 时，useQuery 将在 status === 'error' 时抛出运行时错误\\n  suspense: true,\\n  // 将此设置为 false 以禁止此查询自动运行。https://tanstack.com/query/v4/docs/react/guides/dependent-queries\\n  // 在 userId 存在之前，查询不会执行\\n  enabled: !!userId,\\n  // 如果为 false，失败的查询默认不会重试。如果为真，失败的查询将无限重试\\n  // 如果设置为数字，例如 3、失败的查询会重试，直到失败的查询计数满足那个数\\n  retry: boolean | number | (failureCount: number, error: TError) => boolean\\n  // 默认值为 'online'，请参阅网络模式：https://tanstack.com/query/v4/docs/react/guides/network-mode\\n  networkMode: 'online' | 'always' | 'offlineFirst'\\n  // 如果设置为 false，如果查询包含错误，则不会在挂载时重试。默认为真\\n  retryOnMount: boolean\\n  // 此函数接收一个 retryAttempt 整数和实际错误，并返回在下一次尝试之前应用的延迟（以毫秒为单位）\\n  // 像 attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000) 这样的函数应用指数退避\\n  // 像 attempt => attempt * 1000 这样的函数应用线性退避。\\n  retryDelay: number | (retryAttempt: number, error: TError) => number\\n  // 默认值为 0，数据被认为过时后的时间（以毫秒为单位）。该值仅适用于定义它的挂钩\\n  // 如果设置为“Infinity”，数据将永远不会被认为是陈旧的\\n  staleTime: number | Infinity\\n  // 在 SSR 期间默认为 5 * 60 * 1000（5 分钟）或无限\\n  // 未使用(unused)/非活动(inactive)缓存数据保留在内存中的时间（以毫秒为单位）。当查询的缓存变为未使用或不活动时，该缓存数据将在这段时间后被垃圾收集。 当指定不同的缓存时间时，将使用最长的一个\\n  // 如果设置为 Infinity，将禁用垃圾收集\\n  cacheTime: number | Infinity\\n  // 如果设置为一个数字，所有查询将以毫秒为单位以该频率连续重新获取\\n  // 如果设置为一个函数，该函数将使用最新的数据执行并查询以计算频率\\n  refetchInterval: number | false | ((data: TData | undefined, query: Query) => number | false)\\n  // 如果设置为 true，则设置为使用 refetchInterval 连续重新获取的查询将在其选项卡/窗口处于后台时继续重新获取\\n  refetchIntervalInBackground: boolean\\n  // 默认为 true\\n  // 如果设置为 true，如果数据过时，查询将在挂载时重新获取\\n  // 如果设置为 false，查询将不会在挂载时重新获取\\n  // 如果设置为 always，查询将始终在挂载时重新获取\\n  // 如果设置为一个函数，该函数将与查询一起执行以计算值\\n  refetchOnMount: boolean | \\\"always\\\" | ((query: Query) => boolean | \\\"always\\\")\\n  // 默认为 true\\n  // 如果设置为 true，如果数据陈旧，查询将重新获取窗口焦点\\n  // 如果设置为 false，查询将不会重新获取窗口焦点\\n  // 如果设置为 always，查询将始终重新获取窗口焦点\\n  // 如果设置为一个函数，该函数将与查询一起执行以计算值\\n  refetchOnWindowFocus: boolean | \\\"always\\\" | ((query: Query) => boolean | \\\"always\\\")\\n  // 默认为 true\\n  // 如果设置为 true，如果数据过时，查询将在重新连接时重新获取\\n  // 如果设置为 false，查询将不会在重新连接时重新获取\\n  // 如果设置为 always，查询将始终重新获取窗口焦点\\n  // 如果设置为一个函数，该函数将与查询一起执行以计算值\\n  refetchOnReconnect: boolean | \\\"always\\\" | ((query: Query) => boolean | \\\"always\\\")\\n  // 如果设置，组件将仅在任何列出的属性更改时重新渲染\\n  // 例如，如果设置为 ['data', 'error']，组件将仅在数据或错误属性更改时重新呈现\\n  // 如果设置为“all”，组件将选择退出智能跟踪并在更新查询时重新呈现\\n  // 默认情况下，将跟踪对属性的访问，并且仅当跟踪的属性之一发生更改时，组件才会重新呈现\\n  notifyOnChangeProps: string[] | \\\"all\\\"\\n  // 如果设置，此值将用作查询缓存的初始数据（只要尚未创建或缓存查询）\\n  // 如果设置为一个函数，该函数将在共享/根查询初始化期间被调用一次，并期望同步返回 initialData\\n  // 默认情况下，初始数据被认为是陈旧的，除非设置了 staleTime。\\n  // initialData 被持久化到缓存\\n  initialData: TData | () => TData\\n  // 如果设置，该值将用作上次更新 initialData 本身的时间（以毫秒为单位）。\\n  initialDataUpdatedAt: number | (() => number | undefined)\\n  // 如果设置，当查询仍在加载数据中且未提供 initialData 时，此值将用作此特定查询观察器的占位符数据。\\n  // `placeholderData` 不会持久化到缓存\\n  placeholderData: TData | () => TData\\n  // 默认为 false 如果设置，则在获取新数据时将保留任何以前的数据，因为查询键已更改。\\n  keepPreviousData: boolean\\n  // 默认为 true 如果设置为 false，将禁用查询结果之间的结构共享\\n  // 如果设置为一个函数，旧数据值和新数据值将通过该函数传递，该函数应将它们组合成解析数据以供查询。 这样，您可以保留旧数据的引用以提高性能，即使该数据包含不可序列化的值也是如此\\n  structuralSharing: boolean | ((oldData: TData | undefined, newData: TData) => TData)\\n  // 默认为全局查询配置的 useErrorBoundary 值，未定义\\n  // 如果您希望在渲染阶段抛出错误并传播到最近的错误边界，请将此设置为 true\\n  // 将此设置为 false 以禁用 suspense 将错误抛出到错误边界的默认行为\\n  // 如果设置为函数，它将传递错误和查询，它应该返回一个布尔值，指示是在错误边界中显示错误 (true) 还是将错误作为状态返回 (false)\\n  useErrorBoundary: undefined | boolean | (error: TError, query: Query) => boolean\\n  // 如果设置，则存储有关查询缓存条目的附加信息，可根据需要使用。 只要查询可用，它就可以访问，它也是提供给 queryFn 的 QueryFunctionContext 的一部分\\n  meta: Record<string, unknown>\\n  // 使用它来使用自定义 React 查询上下文。 否则，将使用 defaultContext\\n  context: React.Context<QueryClient | undefined>\\n});\\n```\\n\\n#### Fetch 选项\\n\\n请求 `fetch` 相关参数 \\n\\n```js\\nconst { data } = useReactQuery({\\n  /** 用于设置请求正文的 BodyInit 对象或 null。*/\\n  body?: BodyInit | null;\\n  /** 一个字符串，指示请求将如何与浏览器的缓存交互以设置请求的缓存。*/\\n  cache?: RequestCache;\\n  /** 一个字符串，指示凭据是始终、从不还是仅在发送到同源 URL 时随请求一起发送。 设置请求的凭据。*/\\n  credentials?: RequestCredentials;\\n  /** Headers 对象、对象字面量或包含两项的数组，用于设置请求的标头。*/\\n  headers?: HeadersInit;\\n  /** 要按请求获取的资源的加密哈希。 设置请求的完整性。*/\\n  integrity?: string;\\n  /** 设置请求的保活的布尔值。*/\\n  keepalive?: boolean;\\n  /** 设置请求方法的字符串。(GET|POST|PUT....)*/\\n  method?: string;\\n  /** 一个字符串，指示请求是使用 CORS，还是仅限于同源 URL。 设置请求的模式。*/\\n  mode?: RequestMode;\\n  /** 一个字符串，指示请求是否遵循重定向、在遇到重定向时导致错误或返回重定向（以不透明的方式）。 放s request's redirect. */\\n  redirect?: RequestRedirect;\\n  /** 一个字符串，其值为同源 URL、“about:client”或空字符串，用于设置请求的引荐来源网址。*/\\n  referrer?: string;\\n  /** 设置请求的 referrerPolicy 的引用策略。*/\\n  referrerPolicy?: ReferrerPolicy;\\n  /** 用于设置请求信号的 AbortSignal。*/\\n  signal?: AbortSignal | null;\\n  /** 只能为空。 用于解除来自任何窗口的请求。*/\\n  window?: null;\\n});\\n```\\n\\n### useReactMutation\\n\\n用于触发的 `API` 请求\\n\\n```jsx\\nuseReactMutation({\\n  mutationKey: ['user', dataForm],\\n  url: '/api/login'\\n});\\n```\\n<!--rehype:style=background:#00de2247;border: 0;-->\\n\\n👆👆👆👆 上面是**推荐**使用，**dataForm** 用于给 `body` 传递的 *json* 数据 👆👆👆👆👆\\n\\n```javascript\\nimport { fetchFn, useReactMutation } from '@kkt/request';\\n\\nuseReactMutation({ mutationKey: ['user'], url: '/api/login' });\\nuseReactMutation({ mutationKey: ['user'], url: '/api/login', method: 'PUT' });\\nuseReactMutation({ mutationKey: ['user', dataForm], url: '/api/login' });\\nuseReactMutation({\\n  mutationKey: ['user', dataForm], \\n  mutationFn: () => fetchFn(`/api/login?id=${dataForm.userId}`, { method: 'PUT' })\\n});\\nuseReactMutation({\\n  mutationKey: ['user', dataForm],\\n  mutationFn: () => fetchFn('/api/login', { method: 'POST', body: JSON.stringify(dataForm) }),\\n});\\nuseReactMutation({\\n  mutationKey: ['user', dataForm],\\n  mutationFn: async () => {\\n    return fetchFn(`/api/login?id=${dataForm.username}`, { method: 'DELETE', body: JSON.stringify(dataForm) });\\n  },\\n});\\nuseReactMutation({\\n  mutationKey: ['user', dataForm],\\n  mutationFn: (data) => {\\n    return fetchFn(`/api/login`, { method: 'POST', body: JSON.stringify(data) })\\n  },\\n});\\n```\\n\\n**登录页面**示例\\n\\n```javascript\\nimport { useReactMutation, useAuth } from '@kkt/request';\\nimport { useEffect, useState } from 'react';\\nimport { Form, useNavigate, useLocation } from 'react-router-dom';\\n\\nexport default function LoginPage() {\\n  const [errors, setErrors] = useState()\\n  const [submitData, setSubmitData] = useState()\\n  const location = useLocation();\\n  const navigate = useNavigate();\\n  const mutation = useReactMutation({\\n    url: '/api/login',\\n    mutationKey: ['user-login', submitData],\\n  });\\n\\n  useEffect(() => {\\n    sessionStorage.removeItem('token');\\n    // 默认进入登录页面清空 token，退出登录即可直接跳转到 `/login` 页面\\n  }, []);\\n\\n  const submit = async (event) => {\\n    event.preventDefault();\\n    const result = await mutation.mutateAsync(submitData);\\n    if (result.error) {\\n      setErrors({ message: result.error });\\n      return;\\n    }\\n    // 存储 token，通过 sessionStorage 或者 localStorage\\n    sessionStorage.setItem('token', result.token);\\n    setTimeout(() => {\\n      // 跳转到上一个页面或者 `/`\\n      const from = location.state?.from?.pathname || '/';\\n      navigate(from, { replace: true });\\n    });\\n  };\\n  const handleChange = (event) => {\\n    const formData = new FormData(event.target.form);\\n    const username = formData.get(\\\"username\\\");\\n    const password = formData.get(\\\"password\\\");\\n    const err = {};\\n    // 验证字段\\n    if (typeof username !== \\\"string\\\" || username.length < 3) {\\n      err.username = \\\"用户名必须大于 3 个字符\\\";\\n    }\\n    if (typeof password !== \\\"string\\\" || password.length < 3) {\\n      err.password = \\\"密码必须大于 3 个字符\\\";\\n    }\\n    setErrors({ ...err });\\n    if (!Object.entries(err).length) {\\n      const data = Object.fromEntries(formData)\\n      setSubmitData(data);\\n    }\\n  }\\n  return (\\n    <Form method=\\\"post\\\" onChange={handleChange} onSubmit={submit}>\\n      <label>\\n        <input type=\\\"text\\\" name=\\\"username\\\" />\\n        {errors?.username && <span>{errors.username}</span>}\\n      </label>\\n      <label>\\n        <input type=\\\"text\\\" name=\\\"password\\\" />\\n        {errors?.password && <span>{errors.password}</span>}\\n      </label>\\n      <p>\\n        <button type=\\\"submit\\\">Sign up</button>\\n      </p>\\n      {errors?.message && <div>{errors.message}</div>}\\n    </Form>\\n  );\\n}\\n```\\n\\n在任何给定时刻，`mutation` 只能处于以下状态之一：\\n\\n- `isIdle` or `status === 'idle'` - mutation 当前处于空闲状态或处于新鲜/重置状态\\n- `isLoading` or `status === 'loading'` - mutation 当前正在运行\\n- `isError` or `status === 'error'` - mutation 遇到错误\\n- `isSuccess` or `status === 'success'` - mutation 成功并且 mutation 数据可用\\n\\n除了这些主要状态之外，还可以根据 `mutation` 状态获得更多信息：\\n\\n- `error` - 如果 mutation 处于错误状态，则可以通过 error 属性获得错误。\\n- `data` - 如果 mutation 处于成功状态，则数据可通过 data 属性获得。\\n\\n```javascript\\nconst mutation = useReactMutation({\\n  url: '/api/login',\\n  mutationKey: ['user-login', data],\\n  method: 'PUT'\\n});\\n```\\n\\n#### 副作用 mutation 选项\\n\\n```js\\nconst mutation = useReactMutation({\\n  url: '/api/login',\\n  onMutate: (variables) => {\\n    // mutation 即将发生！\\n    \\n    // 可选地返回包含数据的上下文，例如在回滚时使用\\n    return { id: 1 }\\n  },\\n  onError: (error, variables, context) => {\\n    // 发生错误！\\n    console.log(`rolling back optimistic update with id ${context.id}`)\\n  },\\n  onSuccess: (data, variables, context) => {\\n    // Boom baby!\\n  },\\n  onSettled: (data, error, variables, context) => {\\n    // 错误或成功......没关系！\\n  },\\n})\\n```\\n\\n您可能会发现，在调用 `mutate` 时，您想要触发除 `useReactMutation` 上定义的回调之外的其他回调。 这可用于触发组件特定的副作用。 为此，您可以在 `mutate` 变量之后向 `mutate` 函数提供任何相同的回调选项。 支持的选项包括：`onSuccess`、`onError` 和 `onSettled`。 请记住，如果您的组件在变更完成之前卸载，那么这些额外的回调将不会运行。\\n\\n```js\\nmutation.mutate(todo, {\\n  onSuccess: (data, variables, context) => {\\n    // I will fire second!\\n  },\\n  onError: (error, variables, context) => {\\n    // I will fire second!\\n  },\\n  onSettled: (data, error, variables, context) => {\\n    // I will fire second!\\n  },\\n})\\n```\\n\\n### Query Keys\\n\\nTanStack Query 的核心是基于查询键为您管理查询缓存。查询键必须是顶层的数组，并且可以像具有单个字符串的数组一样简单，也可以像包含许多字符串和嵌套对象的数组一样复杂。 只要查询键是可序列化的，并且对于查询数据是唯一的，就可以使用它！\\n\\n```js\\nuseReactQuery({\\n  url: `https://api.example.com/users?status=${status}&page=${page}`,\\n  queryKey: ['use-list', { status, page }],\\n});\\n```\\n\\n### 请求重试\\n\\n```js\\nconst { isLoading, isError, data } = useReactQuery({\\n  url: `/api/user/list?id=${userId}`,\\n  queryKey: ['user-list', userId],\\n  retry: 10, // 在显示错误之前将重试失败的请求 10 次\\n});\\n```\\n\\n修改 `.anerc.js` 配置，每次尝试的默认 `retryDelay` 设置为双倍（从 `1000` 毫秒开始），但不超过 `30` 秒：\\n\\n```js\\n/** @type {import(\\\"anem\\\").ANEMOptions} */\\nexport const anem = {\\n  reactQuery: {\\n    \\\"defaultOptions\\\": {\\n      \\\"queries\\\": {\\n        retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),\\n      }\\n    }\\n  }\\n}\\n```\\n\\n### 获取全局注册的 QueryClient\\n\\n全局 `QueryClient` 是默认集成的，如果没有使用 `reactQuery=false` 取消注册，可以通过下面方式获取全局 `queryClient` 对象\\n\\n```javascript\\nimport { queryClient, fetchFn } from '@kkt/request';\\n// Or\\nimport { queryClient, fetchFn } from '@kkt/pro';\\n\\n/** @type {import(\\\"@kkt/request\\\").QueryClient} */\\nconst client = queryClient;\\n```\\n\\n## 路由 action 请求示例\\n\\n这与 `react-query` 有所不同，使用 `action` 或者 `loader` 拿到数据，传递给页面的 `props`，这是路由([react-router](https://github.com/remix-run/react-router))带的功能，在 loader 中也可以使用 `react-query`。\\n\\n```jsx\\nimport { redirect, Form, useParams, useLoaderData, useActionData } from '@kkt/pro';\\n\\nEditPage.action = async ({ params, request }) => {\\n  let formData = await request.formData();\\n  const updates = Object.fromEntries(formData);\\n  await fetch('https://api.github.com/repos/uiwjs/uiw')\\n  await updateContact(params.userId, updates);\\n  let userId = formData.get('userId');\\n  console.log('::用户ID:', userId);\\n  // 提交跳转到指定页面\\n  return redirect(`/team/${params.userId}`);\\n};\\n\\nEditPage.loader = async ({ params }) => {\\n  console.log('::进入页面请求API:', params.userId)\\n  return { username: `用户ID: ${params.userId} 获取数据` };\\n};\\n\\nexport default function EditPage() {\\n  let { userId } = useParams();\\n  const data = useLoaderData();\\n  const actionData = useActionData();\\n  console.log('userId', userId, data, actionData);\\n  return (\\n    <div>\\n      编辑页面{userId}\\n      <Form method=\\\"delete\\\">\\n        <input type=\\\"hidden\\\" name=\\\"userId\\\" defaultValue={userId} />\\n        <button type=\\\"submit\\\">Delete Project</button>\\n      </Form>\\n    </div>\\n  );\\n}\\n```\\n\\n每当应用程序向您的路线发送非获取提交（`post`、`put`、`patch`、`delete`）时，都会调用操作。 这可以通过几种方式发生：\\n\\n```jsx\\nEditPage.action = async ({ params, request }) => {\\n  switch (request.method) {\\n    case \\\"PUT\\\": {\\n      let formData = await request.formData();\\n      let name = formData.get(\\\"projectName\\\");\\n      return fakeUpdateProject(name);\\n    }\\n    case \\\"DELETE\\\": {\\n      return fakeDeleteProject(params.id);\\n    }\\n    default: {\\n      throw new Response(\\\"\\\", { status: 405 });\\n    }\\n  }\\n};\\n```\\n\\n### 验证阻止提交\\n\\n```jsx\\n<Form \\n  method=\\\"delete\\\"\\n  onSubmit={(event) => {\\n    if (!confirm(\\\"请确认您要删除此记录。\\\")) {\\n      event.preventDefault();\\n    }\\n  }}\\n>\\n  <input type=\\\"hidden\\\" name=\\\"userId\\\" defaultValue={userId} />\\n  <button type=\\\"submit\\\">Delete Project</button>\\n</Form>\\n```\\n\\n### 在 loader 中使用 `react-query`\\n\\n```javascript\\nimport { queryClient, useQuery, fetchFn, useLoaderData } from '@kkt/pro';\\n\\n/** @type {import(\\\"@kkt/request\\\").QueryClient} */\\nconst client = queryClient;\\n\\nExamplePage.loader = async ({ params, request }) => {\\n  const query = () => fetchFn('/api/user/info', { /* fetch 配置 */ });\\n  return queryClient.fetchQuery(['user-list'], query).catch((err) => {\\n    // 出发错误页面\\n    throw new Response(\\\"\\\", {\\n      status: 404,\\n      statusText: err.message,\\n    });\\n  });\\n}\\n\\nexport default function ExamplePage({ contact }) {\\n  const data = useLoaderData();\\n  // 也可以使用 useQuery 拿到你要的数据\\n  const { data: someData } = useQuery(['user-list']);\\n  console.log('someData', someData)\\n  // ....\\n}\\n```\\n\\n### 提交过程不引起 URL 跳转\\n\\n使用 `useFetcher` 钩子定义一个 `fetcher.Form` 标签\\n\\n```jsx\\nimport { useLoaderData, Form, useFetcher } from \\\"@kkt/pro\\\";\\n\\nFavoritePage.action = async ({ params, request }) => {\\n  let formData = await request.formData();\\n  return updateContact(params.contactId, {\\n    favorite: formData.get(\\\"favorite\\\") === \\\"true\\\",\\n  });\\n}\\n\\nexport default function FavoritePage({ contact }) {\\n  const fetcher = useFetcher();\\n  let favorite = contact.favorite;\\n  return (\\n    <fetcher.Form method=\\\"post\\\">\\n      <button name=\\\"favorite\\\" value={favorite ? \\\"false\\\" : \\\"true\\\"}>\\n        {favorite ? \\\"★\\\" : \\\"☆\\\"}\\n      </button>\\n    </fetcher.Form>\\n  );\\n}\\n```\\n\\n### 获取 URL 参数\\n\\n```jsx\\nEditPage.loader = async ({ request }) => {\\n  const url = new URL(request.url);\\n  const q = url.searchParams.get(\\\"q\\\");\\n  return { query: q };\\n};\\nexport default function EditPage() {\\n  const data = useLoaderData();\\n  return (\\n    <div> 编辑页面{data.query} </div>\\n  );\\n}\\n```\\n\\n### 获取路由参数\\n\\n```jsx\\nEditPage.loader = async ({ request }) => {\\n  // 路由参数：/user/:userId/list\\n  let { userId } = useParams();\\n  return { };\\n};\\n```\\n\\n## 比较 | React Query vs SWR vs Apollo vs RTK Query vs React Router\\n\\n|   | React Query | SWR [_(Website)_][swr] | Apollo Client [_(Website)_][apollo] | RTK-Query [_(Website)_][rtk-query]   | React Router [_(Website)_][react-router] |\\n| ----- | ----- | ----- | ----- | ----- | ----- |\\n| Github Repo / Stars                                | [![][stars-react-query]][gh-react-query] | [![][stars-swr]][gh-swr]    | [![][stars-apollo]][gh-apollo]             | [![][stars-rtk-query]][gh-rtk-query] | [![][stars-react-router]][gh-react-router]                                |\\n| 平台要求 | React | React | React, GraphQL | Redux | React |\\n| 他们的比较 | | (none) | (none) | [Comparison][rtk-query-comparison]   | [Comparison][react-router-comparison] |\\n| 支持的查询语法 | Promise, REST, GraphQL | Promise, REST, GraphQL | GraphQL, Any (Reactive Variables) | Promise, REST, GraphQL | Promise, REST, GraphQL |\\n| 支持的框架 | React | React | React + Others | Any | React |\\n| 缓存策略 | Hierarchical Key -> Value | Unique Key -> Value | Normalized Schema | Unique Key -> Value | Nested Route -> value |\\n| 缓存键策略 | JSON | JSON | GraphQL Query | JSON | Route Path |\\n| 缓存变化检测 | Deep Compare Keys (Stable Serialization) | Shallow Compare Keys | Deep Compare Keys (Unstable Serialization) | Key Referential Equality (===) | Route Change |\\n| 数据变化检测 | Deep Comparison + Structural Sharing | Deep Compare (via `dequal`) | Deep Compare (Unstable Serialization) | Key Referential Equality (===) | Loader Run |\\n| 数据记忆 | Full Structural Sharing | Identity (===) | Normalized Identity | Identity (===) | Identity (===) |\\n| 捆绑尺寸 | [![][bp-react-query]][bpl-react-query]   | [![][bp-swr]][bpl-swr]      | [![][bp-apollo]][bpl-apollo]               | [![][bp-rtk-query]][bpl-rtk-query]   | [![][bp-react-router]][bpl-react-router]  [![][bp-history]][bpl-history] |\\n| API定义位置 | Component, External Config | Component | GraphQL Schema | External Config | Route Tree Configuration |\\n| 查询 | ✅ | ✅ | ✅ | ✅ | ✅ |\\n| 缓存持久化 | ✅ | ✅ | ✅ | ✅ | 🛑 Active Routes Only <sup>8</sup> |\\n| 开发者工具 | ✅ | 🟡 | ✅ | ✅ | 🛑 |\\n| 轮询/间隔 | ✅ | ✅ | ✅ | ✅ | 🛑 |\\n| 并行查询 | ✅ | ✅ | ✅ | ✅ | ✅ |\\n| 依赖查询  | ✅ | ✅ | ✅ | ✅ | ✅ |\\n| 分页查询  | ✅ | ✅ | ✅ | ✅ | ✅ |\\n| 无限查询 | ✅ | ✅ | ✅ | 🛑 | 🛑 |\\n| 双向无限查询 | ✅ | 🔶 | 🔶 | 🛑 | 🛑 |\\n| 无限查询重新获取 | ✅ | ✅ | 🛑 | 🛑 | 🛑 |\\n| 滞后查询数据[^1] | ✅ | 🔶 | 🛑 | ✅ | ✅ |\\n| 选择器 | ✅ | 🛑 | ✅ | ✅ | N/A |\\n| 初始数据 | ✅ | ✅ | ✅ | ✅ | ✅ |\\n| 滚动恢复 | ✅ | ✅ | ✅ | ✅ | ✅ |\\n| 缓存操作 | ✅ | ✅ | ✅ | ✅ | 🛑 |\\n| 过时的查询驳回 | ✅ | ✅ | ✅ | ✅ | ✅ |\\n| 渲染批处理和优化[^2] | ✅ | 🛑 | 🛑 | ✅ | ✅ |\\n| 自动垃圾收集 | ✅ | 🛑 | 🛑 | ✅ | N/A |\\n| mutation 钩子 | ✅ | 🟡 | ✅ | ✅ | ✅ |\\n| 离线突变支持 | ✅ | 🛑 | 🟡 | 🛑 | 🛑 |\\n| 预取 API | ✅ | 🔶 | ✅ | ✅ | ✅ |\\n| 查询取消 | ✅ | 🛑 | 🛑 | 🛑 | ✅ |\\n| 部分查询匹配[^3] | ✅ | 🛑 | 🛑 | ✅ | N/A |\\n| 重新验证时陈旧 |✅ | ✅ | ✅ | ✅ | 🛑 |\\n| 陈旧时间配置 | ✅ | 🛑[^7] | 🛑 | ✅ | 🛑 |\\n| 使用前查询/变更配置[^4] | ✅ | 🛑 | 🛑 | ✅ | ✅ |\\n| 窗口焦点重新获取 | ✅ | ✅ | 🛑 | 🔶 | 🛑 |\\n| 网络状态重新获取 | ✅ | ✅ | ✅ | 🔶 | 🛑 |\\n| 一般缓存脱水/再水化 | ✅ | 🛑 | ✅ | ✅ | ✅ |\\n| 离线缓存 | ✅ (实验性的) | 🛑 | ✅ | 🔶 | 🛑 |\\n| React Suspense(实验性的) | ✅ | ✅ | 🛑 | 🛑 | ✅ |\\n| 抽象/不可知核心 | ✅ | 🛑 | ✅ | ✅ | 🛑 |\\n| 变异后自动重新获取[^5] | 🔶 | 🔶 | ✅ | ✅ | ✅ |\\n| 标准化缓存[^6] | 🛑 | 🛑 | ✅ | 🛑 | 🛑 |\\n\\n[bpl-react-query]: https://bundlephobia.com/result?p=react-query\\n[bp-react-query]: https://badgen.net/bundlephobia/minzip/react-query?label=💾\\n[gh-react-query]: https://github.com/tannerlinsley/react-query\\n[stars-react-query]: https://img.shields.io/github/stars/tannerlinsley/react-query?label=%F0%9F%8C%9F\\n\\n[swr]: https://github.com/vercel/swr\\n[bp-swr]: https://badgen.net/bundlephobia/minzip/swr?label=💾\\n[gh-swr]: https://github.com/vercel/swr\\n[stars-swr]: https://img.shields.io/github/stars/vercel/swr?label=%F0%9F%8C%9F\\n[bpl-swr]: https://bundlephobia.com/result?p=swr\\n\\n[apollo]: https://github.com/apollographql/apollo-client\\n[bp-apollo]: https://badgen.net/bundlephobia/minzip/@apollo/client?label=💾\\n[gh-apollo]: https://github.com/apollographql/apollo-client\\n[stars-apollo]: https://img.shields.io/github/stars/apollographql/apollo-client?label=%F0%9F%8C%9F\\n[bpl-apollo]: https://bundlephobia.com/result?p=@apollo/client\\n\\n[rtk-query]: https://redux-toolkit.js.org/rtk-query/overview\\n[rtk-query-comparison]: https://redux-toolkit.js.org/rtk-query/comparison\\n[rtk-query-bundle-size]: https://redux-toolkit.js.org/rtk-query/comparison#bundle-size\\n[bp-rtk]: https://badgen.net/bundlephobia/minzip/@reduxjs/toolkit?label=💾\\n[bp-rtk-query]: https://badgen.net/bundlephobia/minzip/@reduxjs/toolkit?label=💾\\n[gh-rtk-query]: https://github.com/reduxjs/redux-toolkit\\n[stars-rtk-query]: https://img.shields.io/github/stars/reduxjs/redux-toolkit?label=🌟\\n[bpl-rtk]: https://bundlephobia.com/result?p=@reduxjs/toolkit\\n[bpl-rtk-query]: https://bundlephobia.com/package/@reduxjs/toolkit\\n\\n[react-router]: https://github.com/remix-run/react-router\\n[bp-react-router]: https://badgen.net/bundlephobia/minzip/react-router-dom?label=💾\\n[gh-react-router]: https://github.com/remix-run/react-router\\n[stars-react-router]: https://img.shields.io/github/stars/remix-run/react-router?label=%F0%9F%8C%9F\\n[bpl-react-router]: https://bundlephobia.com/result?p=react-router-dom\\n[bp-history]: https://badgen.net/bundlephobia/minzip/history?label=💾\\n[bpl-history]: https://bundlephobia.com/result?p=history\\n\\n[^1]: 滞后查询数据 — React Query 提供了一种在加载下一个查询时继续查看现有查询数据的方法（类似于 suspense 很快将在本地提供的相同 UX）。 这在编写分页 UI 或无限加载 UI 时非常重要，因为您不希望在请求新查询时显示硬加载状态。 其他库没有此功能，并在新查询加载时为新查询呈现硬加载状态（除非它已被预取）。\\n[^2]: 渲染优化 - React Query 具有出色的渲染性能。 默认情况下，它会自动跟踪访问了哪些字段，并且仅在其中一个字段发生更改时才重新呈现。 如果您想选择退出此优化，将 notifyOnChangeProps 设置为 'all' 将在更新查询时重新呈现您的组件。 例如因为它有新数据，或者表明它正在获取。 React Query 还将批处理更新放在一起，以确保您的应用程序仅在多个组件使用相同查询时重新呈现一次。 如果您只对数据或错误属性感兴趣，则可以通过将 notifyOnChangeProps 设置为 ['data', 'error'] 来进一步减少渲染次数。\\n[^3]: 部分查询匹配 — 因为 React Query 使用确定性查询键序列化，这允许您操作可变的查询组，而不必知道您想要匹配的每个单独的查询键，例如。 您可以重新获取其键中以 todos 开头的每个查询，而不管变量如何，或者您可以使用（或不使用）变量或嵌套属性来定位特定查询，甚至可以使用过滤器函数来仅匹配通过特定条件的查询。\\n[^4]: 使用前查询配置 - 这只是一个奇特的名称，用于配置查询和变更在使用前的行为方式。 例如，一个查询可以预先完全配置为默认值，当需要使用它时，只需要 `useQuery({ queryKey })` ，而不是每次使用都需要传递 fetcher 和/或选项。 SWR 确实具有此功能的部分形式，它允许您预先配置一个默认的提取器，但只是作为一个全局提取器，而不是基于每个查询，而且绝对不是用于突变。\\n[^5]: 突变后自动重新提取 - 为了在突变发生后发生真正的自动重新提取，需要一个模式（就像 graphQL 提供的那样）以及帮助库知道如何识别该模式中的单个实体和实体类型的启发式方法。\\n[^6]: 规范化缓存 — React Query、SWR 和 RTK-Query 目前不支持自动规范化缓存，它描述了在平面架构中存储实体以避免一些高级数据重复。\\n[^7]: SWR 的不可变模式 — SWR 附带一个“不可变”模式，允许您在缓存的生命周期内只获取一次查询，但它仍然没有过时或条件自动重新验证的概念\\n[^8]: React Router 缓存持久性 - React Router 不会缓存超出当前匹配路由的数据。 如果留下一条路线，其数据将丢失。\\n\"\n  }"],"names":["components","data","source"],"sourceRoot":""}